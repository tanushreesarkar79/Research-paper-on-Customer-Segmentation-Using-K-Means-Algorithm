# -*- coding: utf-8 -*-
"""Data 2 scoreVSage.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/120NUtSLXrkth9GHGyI-YOcIqjSsPLKqw

importing dependincies
"""

import numpy as np  # for numpy arrays
import pandas as pd  #for dataframes/data manupulation and representation
import matplotlib.pyplot as plt  # for data visualization
import seaborn as sns
from sklearn.cluster import KMeans  # k means library
from sklearn.metrics import silhouette_score #Imports the silhouette_samples function from the Scikit-Learn library, which will be used to compute the silhouette scores for individual samples.
from sklearn.metrics import silhouette_samples
import matplotlib.cm as cm #Imports the cm module from the Matplotlib library and sets an alias of "cm" for convenience when using color maps. This will be used to assign different colors to each cluster in the visualization.

"""data collection and analysis"""

#loading the data from csv file to pandas dataframe
customer_data = pd.read_csv('/content/dataset_2.csv' ,names=['CustomerID','Gender','Age','Annual_Income','Spending_Score','Ware_Pin','Customer_Pin','Zone'], header=0, encoding='utf-8')

# first five rows in the data frame
customer_data.head()

# finding the number of rows and columns
customer_data.shape

#getting some information about the dataset
customer_data.info()

#checking for missing values
customer_data.isnull().sum()

"""FOR SPENDING SCORE VS AGE"""

X = customer_data.iloc[:,[2,4]].values #splicing the data , taking only the 3rd and 4th column

print(X)

"""CALCULATING AND VISUALIZING SILHOUETTE VALUE FOR EACH POSSIBLE NUMBER OF CLUSTERS (DO NOT CHANGE ANYTHING IN THIS CODE)"""

# Commented out IPython magic to ensure Python compatibility.

# load your dataset
#data = customer_data

# select the columns to use as features for clustering
#X = data[['Spending_score', 'Annual_income']]

# set the number of clusters to test
range_n_clusters = [2, 3, 4, 5, 6]

# perform silhouette analysis for each cluster value
for n_clusters in range_n_clusters:
    # create subplots for silhouette plot and cluster visualization
    fig, (ax1, ax2) = plt.subplots(1, 2)
    fig.set_size_inches(18, 7)

    # set the range for the silhouette plot
    ax1.set_xlim([-0.1, 1])
    ax1.set_ylim([0, len(X) + (n_clusters + 1) * 10])

    # initialize the KMeans clusterer with the current number of clusters
    clusterer = KMeans(n_clusters=n_clusters,n_init="auto",random_state=10)
    cluster_labels = clusterer.fit_predict(X)

    # compute the silhouette score for the current clustering
    silhouette_avg = silhouette_score(X, cluster_labels)
    print("For n_clusters =", n_clusters, "The average silhouette_score is :", silhouette_avg)

    # compute the silhouette values for each sample
    sample_silhouette_values = silhouette_samples(X, cluster_labels)

    y_lower = 10
    for i in range(n_clusters):
        # aggregate the silhouette values for samples belonging to the current cluster
        ith_cluster_silhouette_values = sample_silhouette_values[cluster_labels == i]

        ith_cluster_silhouette_values.sort()

        size_cluster_i = ith_cluster_silhouette_values.shape[0]
        y_upper = y_lower + size_cluster_i

        # choose a color for the current cluster
        color = cm.nipy_spectral(float(i) / n_clusters)
        ax1.fill_betweenx(
            np.arange(y_lower, y_upper),
            0,
            ith_cluster_silhouette_values,
            facecolor=color,
            edgecolor=color,
            alpha=0.7,
        )

        # label the silhouette plots with their cluster numbers at the middle
        ax1.text(-0.05, y_lower + 0.5 * size_cluster_i, str(i))

        # update the y_lower value for the next cluster
        y_lower = y_upper + 10  # 10 for the 0 samples

    # add labels and title for the silhouette plot
    ax1.set_title("The silhouette plot for the various clusters.")
    ax1.set_xlabel("The silhouette coefficient values")
    ax1.set_ylabel("Cluster label")

    # add a vertical line for the average silhouette score
    ax1.axvline(x=silhouette_avg, color="red", linestyle="--")

    # clear yaxis labels/ticks for better visualization
    ax1.set_yticks([])

    # set the xaxis ticks for the silhouette plot
    ax1.set_xticks([-0.1, 0, 0.2, 0.4, 0.6, 0.8, 1])

    # 2nd Plot showing the actual clusters formed
    colors = cm.nipy_spectral(cluster_labels.astype(float) / n_clusters)
    ax2.scatter(
        X[:, 0], X[:, 1], marker=".", s=30, lw=0, alpha=0.7, c=colors, edgecolor="k"
    )

    # Labeling the clusters
    centers = clusterer.cluster_centers_
    # Draw white circles at cluster centers
    ax2.scatter(
        centers[:, 0],
        centers[:, 1],
        marker="o",
        c="white",
        alpha=1,
        s=200,
        edgecolor="k",
    )

    for i, c in enumerate(centers):
        ax2.scatter(c[0], c[1], marker="$%d$" % i, alpha=1, s=50, edgecolor="k")

    ax2.set_title("The visualization of the clustered data.")
    ax2.set_xlabel("Feature space for the 1st feature")
    ax2.set_ylabel("Feature space for the 2nd feature")

    plt.suptitle(
        "Silhouette analysis for KMeans clustering on sample data with n_clusters = %d"
#         % n_clusters,
        fontsize=14,
        fontweight="bold",
    )

plt.show()

"""To choose the correct number of clusters

WCSS-> within sum of squares

(EKHANEO NO CHANGE)
"""

#elbow method for finding wcss value for different number of clusters

wcss = []
silhouette_scores = []

for i in range(2,11):
  kmeans = KMeans(n_clusters=i, init='k-means++',random_state=42)
  kmeans.fit(X)

  wcss.append(kmeans.inertia_) #inertia function lies within the kmeans algorith and gives us the wcss values
  silhouette_scores.append(silhouette_score(X, kmeans.labels_))# Calculate the silhouette score for the current number of clusters

"""Plotting an elbow and silhouette score graph

(no change here )
"""

sns.set()
fig, ax = plt.subplots(1, 2, figsize=(15,5))
ax[0].plot(range(2,11),wcss)
ax[0].set_title('Elbow Graph')
ax[0].set_xlabel('Number of Clusters')
ax[0].set_ylabel('WCSS')

ax[1].plot(range(2,11), silhouette_scores)
ax[1].set_title('Silhouette Score')
ax[1].set_xlabel('Number of Clusters')
ax[1].set_ylabel('Score')

plt.show()

"""Optimum number of clusters = n (EKHANE VALUE CHANGE KORBI AFTER ANALYSING ALL THE ABOVE GRAPHS)

n_clusters er value oh change korbi tokhon

training the k means model
"""

kmeans = KMeans(n_clusters=5, init='k-means++',random_state=0)

#return a label for each data point based on their cluster

Y = kmeans.fit_predict(X)   #returns a cluster number for each of the data points

print(Y)

"""visualising the clusters"""

#plotting all the clusters and their centroids

plt.figure(figsize=(10,10))
plt.scatter(X[Y==0,0], X[Y==0,1], s=50, c='green', label='Cluster 1')
plt.scatter(X[Y==1,0], X[Y==1,1], s=50, c='red', label='Cluster 2')
plt.scatter(X[Y==2,0], X[Y==2,1], s=50, c='yellow', label='Cluster 3')
plt.scatter(X[Y==3,0], X[Y==3,1], s=50, c='violet', label='Cluster 4')
plt.scatter(X[Y==4,0], X[Y==4,1], s=50, c='blue', label='Cluster 5')
plt.scatter(X[Y==5,0], X[Y==5,1], s=50, c='cyan', label='Cluster 6')

#plot the centroids
plt.scatter(kmeans.cluster_centers_[:,0],kmeans.cluster_centers_[:,1], s=200, c='black', label='Centroids')

plt.title('Customer Groups')
plt.xlabel('Age')
plt.ylabel('Spending Score')
plt.show()

"""Adding a new column called clusters to the dataframe"""

# Create data arrays
cluster_centers = kmeans.cluster_centers_
data = np.expm1(cluster_centers)  # NumPy expm1 function returns the exponential value of minus one for each element given inside a NumPy array as output. Therefore, the np.expm1 method accepts arr_name and out arguments and then returns the array as outputs.
points = np.append(data, cluster_centers, axis=1)
points

# Add "clusters" to customers data
points = np.append(points, [[0], [1], [2],[3],[4]], axis=1)
customer_data["clusters"] = kmeans.labels_

customer_data.head()

"""BAR GRAPH for no of elements in each clusters"""

valcount = customer_data.clusters.value_counts()
plt.figure(figsize=(8,6))
plt.bar(valcount.index,valcount.values)
176
plt.title('Elements Per Cluster')
plt.show()